{
    "title": "Arbitrary reads with Format String Vulnerabilities",
    "content": "1. What is a format string vulnerability?\n\nFormat string vulnerabilities are when an unsantized user input is passed to a function that handles formatted strings with no format specifiers. The most common vulnerable functions are variants of printf. For insance, to print a string in C, a printf with the appropriate format specifier for the data type provided should be used.\n\nExample:\n\n\t\t//This is the wrong way!\n\t\tint size = 10;\n\t\tchar greet[size];\n\t\tfgets(greet, size, stdin);\n\t\tprintf(\"Hello, \");\n\t\tprintf(greet);\n\n\t\t//This is the correct way!\n\t\tint size = 10;\n\t\tchar greet[size];\n\t\tfgets(greet, size, stdin);\n\t\tprintf(\"Hello, %s!\\n\");\n\nFormat specifiers for each data type are as follows:\n%s\t-\tstring\n%c\t-\tcharacter\n%p\t-\tpinter\n%d/%i\t-\tsigned integer\n%u\t-\tunsigned integer\n%o\t-\toctal\n%x\t-\thexadecimal\n%f\t-\tfloat\n%e\t-\tscientific notation\n\n2. Arbitrary read\n\nIf the string input into printf is not properly formatted, hackers are able to write their own format specifiers to the string. Take for instance the following pseudocode:\n\n\tuser_string = \"%s\"\n\tprintf(user_string);\n\nNotice how there is a formatted string, but the printf does not have a second argument? What will the format string retrieve?\n\n2.a The stack\n\nThe stack is a region of memory the program allocates at runtime to track variables, function calls, and other binary protection mechanisms such as stack canaries.\n\n3. Hands on portion\n\nPlease ssh to 34.172.170.167:2222 with the password: l!f3_l0ng_l34rn3r\n\tssh -p 2222 student@34.172.170.167\n\nIn your home directory, you should see source code for the vulnerable application. Open this in vim. Any other text editor is heresy.\n\n\tvim src/arb_read.c\n\n3.a vim cheat sheet\n\ni\t-\tinsert mode\nesc\t-\texit mode\n:w\t-\twrite changes\n:wq\t-\twrite changes and quit\n::q!\t-\texit and dont save changes\n\nHow could a hacker steal our very proprietary flags? Lets walk through the code flow of our application. Main calls vuln. Inside of vuln, the flag gets retrieved pre authentication, the application asks for a password, checks, and if the password is valid, the flag is printed. If the password is not valid, it prints the password we attempted, but how it handles the printing of this password is the problem. It sends our input directly to the printf without formatting it properly. So, if we type in a format specifier as the password, we can do some interesting things. But first, lets understand what happens under the hood. Whenever we send a password to the program, our password gets placed on the same stack n number of bytes below the flag. Using a debugger such as GDB can help check the stack during runtime, but thats beyond the scope of this lesson. Below is an example of the stack during runtime. You can see our password, and further up the stack you can see the flag! But we can't use a debugger to retrieve the flag if the service is remote, so we need to craft an exploit to get the flag from a process we don't control!<br><img src=\"./static/stack_gdb.png\">\n\nNow that we have a good idea about what the stack looks like, and how to exploit this vulnerability, lets try it!\n\n\t./bin/arb_read\n\nLets try \"%s\" as a password. As you can see, the program printed one of the strings that was already printed. These strings were already on the stack! <br><img src=\"./static/arb_read_test.png\">\n\nSo now that we know we can read strings on the stack, and we know the flag was placed on the stack, perhaps we can recover it? How far up the stack is our flag? We can fuzz our program to find it! Try putting \"%s %s %s\". We can see that three addresses on the stack were printed as strings, but not everything on the stack can be represented as a string. What happens if we keep adding more %s? Likely we will end up segfaulting somewhere along the way. So how can we overcome this problem and read values on the stack that won't crash the program?\n\nLets try format string positional parameters! We can specify what position on the stack we want with the following format: %<int>$<format>. For instance, %3$s should print the 3rd value as a string from the stack. You can confirm this by looking at the last output from our string of three %s we tried earlier. So now we have an extra tool, can we get the flag? We know the flag is fairly close on the stack, so lets just enumerate the memory space by hand. Increment the positional parameter until you get the flag to print. This can vary based on how the binary was compiled, but for this environment, the positional parameter should be 20.\n\n\t./bin/arb_read < <(python3 -c 'print(\"%20$s\")') | grep flag{ | cut -d \" \" -f 8\n\nBut this only gives us the flag of the local binary we are running. The real flag is on a remote service! Lets craft a pwntools script to retrieve the flag from the remote service. Open exploit_read.py and change the payload to reflect what we've discovered.\n\n\t./exploit_read.py\n\nCongratulations, you have successfully replicated the attack that hackers would use to steal allll of our flags. Now that you understand how this works, and why, please patch the vulnerability in the C code and run 'make arb_read_patched' to compile the binary.\n\n\t./bin/arb_read_patched < <(python3 -c 'print(\"%20$s\")')\n\nIf you've patched the program correctly, this exploit shouldn't work anymore! This concludes the lesson on arbitrary reads with format string vulnerabilities. Writes are very similar, but are able to be patched the exact same way."
}
